<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JS Array</title>
</head>
<body>
<h1>Array</h1>
<script>
// 배열생성 방법
// 방법1
var points = [40, 100, 1, 5, 25, 10];
var fruits = ["Banana", "Orange", "Apple", "Mango"];

// 방법2 : new 사용
var cars = new Array("Saab", "Volvo", "BMW");

document.write(points + "<br>");
document.write(points.toString() + "<br>");


// object 의 property 에 대한 접근 횟수를 줄이는게
// 성능에 유리하다.

for(var i = 0; i < cars.length; i++){
    document.write(cars[i] + " ")
}
document.write("<br>");

var l = cars.length;
for(i = 0; i < l; i++){
    document.write(cars[i] + " ");
}

document.write("<br><hr>");

// for (  in  )
for(x in cars){  // value 가 아닌 index
    document.write(cars[x] + " ");
}

document.write("<br>")

// for (  of   )  <-- iterable 객체에 대해, ES6 이상
for(var v of cars){   // 원소값이 담긴다.
    document.write(v + " ")
}

//배열.forEach(함수);
// 배열원소를 하나하나 뽑아내면서 함수호출

document.write("<br>");
function myFunction(value){
    document.write(value + " ");
}
cars.forEach(myFunction);
document.write("<br>");

// 배열 원소 추가
fruits[fruits.length] = 'Melon';
document.write(fruits + "<br>");

fruits.push("Lemon");  // ★
document.write(fruits + "<br>");

// 현재 변수가 배열인지 아닌지 판단
document.write(typeof fruits + "<br>");

// Array.isArray() : 구 브라우저에서는 동작 안함  (ES5.1부터)
document.write(Array.isArray(fruits) + "<br>");

// 구 브라우저에서 동작시키려면 함수 하나만들어 쓰자
function isArray(x){
    return x.constructor.toString().indexOf("Array") > -1;
}
document.write(isArray(fruits) + "<br>");

// instanceof 연산자 사용
document.write((fruits instanceof Array) + "<br>");

// join() 
// 배열 안의 원소들을 묶어서 '하나의 문자열'로 리턴
document.write(cars.join("***") + "<br>")

// push() : 배열끝 원소 추가
// pop() : 배열 끝 원소 추출
// shift() : 배열 첫 원소 추출
// unshift() : 배열앞에 원소 추가, 새로운 length 리턴
document.write("<hr>");
document.write(fruits + "<br>");
document.write(fruits.pop() + "<br>");
document.write(fruits + "<br>");
document.write(fruits.shift() + "<br>");
document.write(fruits + "<br>");
document.write(fruits.unshift("Lemon") + "<br>");
document.write(fruits + "<br>");

// splicing
//  첫번째 매개변수 : 삽입될 데이터 위치
//  두번째 매개변수 : 삭제될 데이터 개수
//  세번째 이후 .. : 삽입될 데이터 들..

fruits.splice(2, 0, "Kiwi", "Banana");
document.write(fruits + "<br>");

fruits.splice(2, 2, "Grape");
document.write(fruits + "<br>")

// 배열 데이터 삭제 : splice 사용
fruits.splice(0, 1);
document.write(fruits + "<br>");


// delete 를 사용하여 배열 원소 삭제

// TODO

// delete 보다는 
// pop(), shift(), splice() 를 사용하길 ㅊㅊ

// concat() 
fruits = fruits.concat(['Grape', "Lemon"])
document.write(fruits + "<br>");


// slice()
// 배열의 부분을 추출, 원본에는 영향 안줌

document.write(fruits.slice(1) + "<br>")    // 1번째 부터 끝까지
document.write(fruits.slice(1, 3) + "<br>")  // 1부터 3 전까지



</script>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>










































