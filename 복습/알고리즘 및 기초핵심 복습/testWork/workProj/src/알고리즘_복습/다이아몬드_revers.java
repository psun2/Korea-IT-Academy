package 알고리즘_복습;

public class 다이아몬드_revers {

	public static void main(String[] args) {

//		10
//	0.	***** ***** 1 j 가 5일때 공백
//	1.	****   **** 3 j 가 4,5,6일때 공백
//	2.	***     *** 5 j 가 j 가 3,4,5,6,7일때 공백
//	3.	**       ** 7 j 가 j 가 2,3,4,5,6,7,8일때 공백
//	4.	*         * 9 j 가 j 가 1,2,3,4,5,6,7,8,9일때 공백
//	5.	**       **
//	6.	***     ***
//	7.	****   ****
//	8.	***** *****

//		1. 바깥포문 은 9줄 까지 찍힌다.
//		2. 안쪽포문은 가로로 10까지 찍힌다.

//		알고리즘 생각
//		첫 루프 => j의 인덱스 번호 5를 기준으로 공백 5 + i 또는 5 - i 또는 j == 5 일때
//		두번째 루프 => j의 인덱스 번호 5를 기준으로 4, 5, 6
//		j == 5 일때 탈락
//		i는 1일때 5 + i(6) 또는 5 - i(4) 두개의 조건이 만족 한다면?
//		i는 1일때 5 - i(4) <= j && 5 + i(6) >= j 두 조건이 만족하는 값은 ? 4,5,6 ok

//		계속 조건이 맞아 떨어지다가
//		0.	***** ***** 
//		1.	****   **** 
//		2.	***     *** 
//		3.	**       ** 
//		4.	*         *
		
//		i 가 5가 될때 조건이 불합격 i 가 5 ~ 8 까지 계속 공백 시전
//		5 - i(4) <= j && 5 + i(6) >= j  조건식에서 i를 강제적으로 바꾸어 주어야함
//		i는 1일때 if(i >= 5) i가 5보다 같거나 클때 부터 조건을 따로 생성해준다.
//		저 조건식에서의 i를 4,3,2,1 으로 줄이면 되겠네 ?
//		i 는 5부터 5,6,7,8 까지 늘어납니다.
//		맨 끝 인덱스에서 현재의 i 를 뺀다면 ?
//		i 는 4,3,2,1 이 됩니다.
		
//		변수를 하나 생성하여, 처음에는 i 값을 가지다가
//		i 가 5랑 같거나 크다 라는 조건을 걸고 맨끝 인덱스에서 현재의 i 값을 빼주는 조건식 성립
		
//		***** *****
//		****   ****
//		***     ***
//		**       **
//		*         *
//		**       **
//		***     ***
//		****   ****
//		***** *****


		int half = 5;
		for (int i = 0; i < 9; i++) {
			int half_i = i;
			if (i >= 5) {
				half_i = 8 - i;
			}
			for (int j = 0; j < 11; j++) {
//				if (half - i <= j && half + i >= j) {
				if (half - half_i <= j && half + half_i >= j) {
					System.out.print(" ");
				} else {
					System.out.print("*");
				}
			}
			System.out.println();
		}

	}

}
